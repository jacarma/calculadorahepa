{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../RangePips.svelte",
    "../../RangeSlider.svelte",
    "../../Room.svelte"
  ],
  "sourcesContent": [
    "<script>\n\n  // range slider props\n  export let range = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n\n  // range pips / values props\n  export let pipstep = undefined;\n  export let all = true;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = v => v;\n\n  // stylistic props\n  export let focus = undefined;\n  export let percentOf = undefined;\n\n  $: pipStep = pipstep || ((max - min) / step >= ( vertical ? 50 : 100 ) ? (max - min) / ( vertical ? 10 : 20 ) : 1);\n\n  $: pipCount = parseInt((max - min) / (step * pipStep), 10);\n\n  $: pipVal = function(val) {\n    return min + val * step * pipStep;\n  };\n\n  $: isSelected = function(val) {\n    return values.some(v => v === val);\n  };\n\n  $: inRange = function(val) {\n    if (range === \"min\") {\n      return values[0] > val;\n    } else if (range === \"max\") {\n      return values[0] < val;\n    } else if (range) {\n      return values[0] < val && values[1] > val;\n    }\n  };\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --pip: var(--range-pip, lightslategray);\n    --pip-text: var(--range-pip-text, var(--pip));\n    --pip-active: var(--range-pip-active, darkslategrey);\n    --pip-active-text: var(--range-pip-active-text, var(--pip-active));\n    --pip-in-range: var(--range-pip-in-range, var(--pip-active));\n    --pip-in-range-text: var(--range-pip-in-range-text, var(--pip-active-text));\n  }\n  :global(.rangePips) {\n    position: absolute;\n    height: 1em;\n    left: 0;\n    right: 0;\n    bottom: -1em;\n  }\n  :global(.rangePips.vertical) {\n    height: auto;\n    width: 1em;\n    left: 100%;\n    right: auto;\n    top: 0;\n    bottom: 0;\n  }\n  :global(.rangePips .pip) {\n    height: 0.4em;\n    position: absolute;\n    top: 0.25em;\n    width: 1px;\n    white-space: nowrap;\n  }\n  :global(.rangePips.vertical .pip) {\n    height: 1px;\n    width: 0.4em;\n    top: 0;\n    left: 0.25em;\n  }\n  :global(.rangePips .pip.selected) {\n    height: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected) {\n    height: 1px;\n    width: 0.75em;\n  }\n  :global(.rangePips .pipVal) {\n    position: absolute;\n    top: 0.4em;\n    transform: translate(-50%, 25%);\n  }\n  :global(.rangePips.vertical .pipVal) {\n    position: absolute;\n    top: 0;\n    left: 0.4em;\n    transform: translate(25%, -50%);\n  }\n  :global(.rangePips .pip.selected .pipVal) {\n    font-weight: bold;\n    top: 0.75em;\n  }\n  :global(.rangePips.vertical .pip.selected .pipVal) {\n    top: 0;\n    left: 0.75em;\n  }\n  :global(.rangePips .pip, .rangePips .pipVal) {\n    transition: all 0.15s ease;\n  }\n  :global(.rangePips .pip) {\n    color: lightslategray;\n    color: var(--pip-text);\n    background-color: lightslategray;\n    background-color: var(--pip);\n  }\n  :global(.rangePips .pip.selected) {\n    color: darkslategrey;\n    color: var(--pip-active-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-active);\n  }\n  :global(.rangePips .pip.in-range) {\n    color: darkslategrey;\n    color: var(--pip-in-range-text);\n    background-color: darkslategrey;\n    background-color: var(--pip-in-range);\n  }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zdmVsdGUtcmFuZ2Utc2xpZGVyLXBpcHMvc3JjL1JhbmdlUGlwcy5zdmVsdGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtFQUNFO0lBQ0UsdUNBQXVDO0lBQ3ZDLDZDQUE2QztJQUM3QyxvREFBb0Q7SUFDcEQsa0VBQWtFO0lBQ2xFLDREQUE0RDtJQUM1RCwyRUFBMkU7RUFDN0U7RUFDQTtJQUNFLGtCQUFrQjtJQUNsQixXQUFXO0lBQ1gsT0FBTztJQUNQLFFBQVE7SUFDUixZQUFZO0VBQ2Q7RUFDQTtJQUNFLFlBQVk7SUFDWixVQUFVO0lBQ1YsVUFBVTtJQUNWLFdBQVc7SUFDWCxNQUFNO0lBQ04sU0FBUztFQUNYO0VBQ0E7SUFDRSxhQUFhO0lBQ2Isa0JBQWtCO0lBQ2xCLFdBQVc7SUFDWCxVQUFVO0lBQ1YsbUJBQW1CO0VBQ3JCO0VBQ0E7SUFDRSxXQUFXO0lBQ1gsWUFBWTtJQUNaLE1BQU07SUFDTixZQUFZO0VBQ2Q7RUFDQTtJQUNFLGNBQWM7RUFDaEI7RUFDQTtJQUNFLFdBQVc7SUFDWCxhQUFhO0VBQ2Y7RUFDQTtJQUNFLGtCQUFrQjtJQUNsQixVQUFVO0lBQ1YsK0JBQStCO0VBQ2pDO0VBQ0E7SUFDRSxrQkFBa0I7SUFDbEIsTUFBTTtJQUNOLFdBQVc7SUFDWCwrQkFBK0I7RUFDakM7RUFDQTtJQUNFLGlCQUFpQjtJQUNqQixXQUFXO0VBQ2I7RUFDQTtJQUNFLE1BQU07SUFDTixZQUFZO0VBQ2Q7RUFDQTtJQUNFLDBCQUEwQjtFQUM1QjtFQUNBO0lBQ0UscUJBQXFCO0lBQ3JCLHNCQUFzQjtJQUN0QixnQ0FBZ0M7SUFDaEMsNEJBQTRCO0VBQzlCO0VBQ0E7SUFDRSxvQkFBb0I7SUFDcEIsNkJBQTZCO0lBQzdCLCtCQUErQjtJQUMvQixtQ0FBbUM7RUFDckM7RUFDQTtJQUNFLG9CQUFvQjtJQUNwQiwrQkFBK0I7SUFDL0IsK0JBQStCO0lBQy9CLHFDQUFxQztFQUN2QyIsImZpbGUiOiJub2RlX21vZHVsZXMvc3ZlbHRlLXJhbmdlLXNsaWRlci1waXBzL3NyYy9SYW5nZVBpcHMuc3ZlbHRlIiwic291cmNlc0NvbnRlbnQiOlsiXG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyKSB7XG4gICAgLS1waXA6IHZhcigtLXJhbmdlLXBpcCwgbGlnaHRzbGF0ZWdyYXkpO1xuICAgIC0tcGlwLXRleHQ6IHZhcigtLXJhbmdlLXBpcC10ZXh0LCB2YXIoLS1waXApKTtcbiAgICAtLXBpcC1hY3RpdmU6IHZhcigtLXJhbmdlLXBpcC1hY3RpdmUsIGRhcmtzbGF0ZWdyZXkpO1xuICAgIC0tcGlwLWFjdGl2ZS10ZXh0OiB2YXIoLS1yYW5nZS1waXAtYWN0aXZlLXRleHQsIHZhcigtLXBpcC1hY3RpdmUpKTtcbiAgICAtLXBpcC1pbi1yYW5nZTogdmFyKC0tcmFuZ2UtcGlwLWluLXJhbmdlLCB2YXIoLS1waXAtYWN0aXZlKSk7XG4gICAgLS1waXAtaW4tcmFuZ2UtdGV4dDogdmFyKC0tcmFuZ2UtcGlwLWluLXJhbmdlLXRleHQsIHZhcigtLXBpcC1hY3RpdmUtdGV4dCkpO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlUGlwcykge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBoZWlnaHQ6IDFlbTtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogLTFlbTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVBpcHMudmVydGljYWwpIHtcbiAgICBoZWlnaHQ6IGF1dG87XG4gICAgd2lkdGg6IDFlbTtcbiAgICBsZWZ0OiAxMDAlO1xuICAgIHJpZ2h0OiBhdXRvO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VQaXBzIC5waXApIHtcbiAgICBoZWlnaHQ6IDAuNGVtO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDAuMjVlbTtcbiAgICB3aWR0aDogMXB4O1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VQaXBzLnZlcnRpY2FsIC5waXApIHtcbiAgICBoZWlnaHQ6IDFweDtcbiAgICB3aWR0aDogMC40ZW07XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDAuMjVlbTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVBpcHMgLnBpcC5zZWxlY3RlZCkge1xuICAgIGhlaWdodDogMC43NWVtO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlUGlwcy52ZXJ0aWNhbCAucGlwLnNlbGVjdGVkKSB7XG4gICAgaGVpZ2h0OiAxcHg7XG4gICAgd2lkdGg6IDAuNzVlbTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVBpcHMgLnBpcFZhbCkge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDAuNGVtO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDI1JSk7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VQaXBzLnZlcnRpY2FsIC5waXBWYWwpIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDAuNGVtO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDI1JSwgLTUwJSk7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VQaXBzIC5waXAuc2VsZWN0ZWQgLnBpcFZhbCkge1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHRvcDogMC43NWVtO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlUGlwcy52ZXJ0aWNhbCAucGlwLnNlbGVjdGVkIC5waXBWYWwpIHtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMC43NWVtO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlUGlwcyAucGlwLCAucmFuZ2VQaXBzIC5waXBWYWwpIHtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4xNXMgZWFzZTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVBpcHMgLnBpcCkge1xuICAgIGNvbG9yOiBsaWdodHNsYXRlZ3JheTtcbiAgICBjb2xvcjogdmFyKC0tcGlwLXRleHQpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0c2xhdGVncmF5O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBpcCk7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VQaXBzIC5waXAuc2VsZWN0ZWQpIHtcbiAgICBjb2xvcjogZGFya3NsYXRlZ3JleTtcbiAgICBjb2xvcjogdmFyKC0tcGlwLWFjdGl2ZS10ZXh0KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBkYXJrc2xhdGVncmV5O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBpcC1hY3RpdmUpO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlUGlwcyAucGlwLmluLXJhbmdlKSB7XG4gICAgY29sb3I6IGRhcmtzbGF0ZWdyZXk7XG4gICAgY29sb3I6IHZhcigtLXBpcC1pbi1yYW5nZS10ZXh0KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBkYXJrc2xhdGVncmV5O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBpcC1pbi1yYW5nZSk7XG4gIH1cbiJdfQ== */</style>\n\n<div class=\"rangePips\" class:focus class:vertical>\n  {#if ( all && first !== false ) || first }\n    <span\n      class=\"pip first\"\n      class:selected={isSelected(min)}\n      class:in-range={inRange(min)}\n      style=\"{vertical ? 'top' : 'left'}: 0%;\">\n      {#if all === 'label' || first === 'label'}\n        <span class=\"pipVal\">\n          {prefix}{formatter(min)}{suffix}\n        </span>\n      {/if}\n    </span>\n  {/if}\n  {#if ( all && rest !== false ) || rest}\n    {#each Array(pipCount + 1) as _, i}\n      {#if pipVal(i) !== min && pipVal(i) !== max}\n        <span\n          class=\"pip\"\n          class:selected={isSelected(pipVal(i))}\n          class:in-range={inRange(pipVal(i))}\n          style=\"{vertical ? 'top' : 'left'}: {percentOf(pipVal(i))}%;\">\n          {#if all === 'label' || rest === 'label'}\n            <span class=\"pipVal\">\n              {prefix}{formatter(pipVal(i))}{suffix}\n            </span>\n          {/if}\n        </span>\n      {/if}\n    {/each}\n  {/if}\n  {#if ( all && last !== false ) || last}\n    <span\n      class=\"pip last\"\n      class:selected={isSelected(max)}\n      class:in-range={inRange(max)}\n      style=\"{vertical ? 'top' : 'left'}: 100%;\">\n      {#if all === 'label' || last === 'label'}\n        <span class=\"pipVal\">\n          {prefix}{formatter(max)}{suffix}\n        </span>\n      {/if}\n    </span>\n  {/if}\n</div>\n",
    "<script>\n  import { spring } from \"svelte/motion\";\n  import RangePips from \"./RangePips.svelte\";\n\n  // range slider props\n  export let range = false;\n  export let min = 0;\n  export let max = 100;\n  export let step = 1;\n  export let values = [(max + min) / 2];\n  export let vertical = false;\n  export let float = false;\n  export let hover = true;\n\n  // range pips / values props\n  export let pips = false;\n  export let pipstep = undefined;\n  export let all = undefined;\n  export let first = undefined;\n  export let last = undefined;\n  export let rest = undefined;\n\n  // formatting props\n  export let id = undefined;\n  export let prefix = \"\";\n  export let suffix = \"\";\n  export let formatter = (v) => v;\n  export let handleFormatter = formatter;\n\n  // stylistic props\n  export let precision = 2;\n  export let springValues = { stiffness: 0.15, damping: 0.4 };\n\n  // dom references\n  let slider;\n\n  // state management\n  let focus = false;\n  let handleActivated = false;\n  let keyboardActive = false;\n  let activeHandle = values.length - 1;\n\n  // save spring-tweened copies of the values for use\n  // when changing values and animating the handle/range nicely\n  let springPositions = spring(\n    values.map((v) => parseFloat((((v - min) / (max - min)) * 100).toFixed(precision))),\n    springValues\n  );\n\n  // watch the values array, and trim / clamp the values to the steps\n  // and boundaries set up in the slider on change\n  $: values = trimRange(values).map((v) => alignValueToStep(v));\n\n  // update the spring function so that movement can happen in the UI\n  $: {\n    springPositions.set(values.map((v) => percentOf(v)));\n  }\n\n  /**\n   * take in a value, and then calculate that value's percentage\n   * of the overall range (min-max);\n   * @param {number} val the value we're getting percent for\n   * @return {number} the percentage value\n   **/\n  $: percentOf = function (val) {\n    let perc = ((val - min) / (max - min)) * 100;\n    if (perc >= 100) {\n      return 100;\n    } else if (perc <= 0) {\n      return 0;\n    } else {\n      return parseFloat(perc.toFixed(precision));\n    }\n  };\n\n  /**\n   * clamp a value from the range so that it always\n   * falls within the min/max values\n   * @param {number} val the value to clamp\n   * @return {number} the value after it's been clamped\n   **/\n  $: clampValue = function (val) {\n    // return the min/max if outside of that range\n    return val <= min ? min : val >= max ? max : val;\n  };\n\n  /**\n   * align the value with the steps so that it\n   * always sits on the closest (above/below) step\n   * @param {number} val the value to align\n   * @return {number} the value after it's been aligned\n   **/\n  $: alignValueToStep = function (val) {\n    // sanity check for performance\n    if (val <= min) {\n      return min;\n    } else if (val >= max) {\n      return max;\n    }\n\n    // find the middle-point between steps\n    // and see if the value is closer to the\n    // next step, or previous step\n    let remainder = (val - min) % step;\n    let aligned = val - remainder;\n    if (Math.abs(remainder) * 2 >= step) {\n      aligned += remainder > 0 ? step : -step;\n    }\n    // make sure the value is within acceptable limits\n    aligned = clampValue(aligned);\n    // make sure the returned value is set to the precision desired\n    // this is also because javascript often returns weird floats\n    // when dealing with odd numbers and percentages\n\n    return parseFloat(aligned.toFixed(precision));\n  };\n\n  /**\n   * helper func to get the index of an element in it's DOM container\n   * @param {object} el dom object reference we want the index of\n   * @returns {number} the index of the input element\n   **/\n  function index(el) {\n    if (!el) return -1;\n    var i = 0;\n    while ((el = el.previousElementSibling)) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * noramlise a mouse or touch event to return the\n   * client (x/y) object for that event\n   * @param {event} e a mouse/touch event to normalise\n   * @returns {object} normalised event client object (x,y)\n   **/\n  function normalisedClient(e) {\n    if (e.type.includes(\"touch\")) {\n      return e.touches[0];\n    } else {\n      return e;\n    }\n  }\n\n  /**\n   * get the position (x/y) of a mouse/touch event on the screen\n   * @param {event} e a mouse/touch event\n   * @returns {object} position on screen (x,y)\n   **/\n  function eventPosition(e) {\n    return vertical ? normalisedClient(e).clientY : normalisedClient(e).clientX;\n  }\n\n  /**\n   * check if an element is a handle on the slider\n   * @param {object} el dom object reference we want to check\n   * @returns {boolean}\n   **/\n  function targetIsHandle(el) {\n    const handles = slider.querySelectorAll(\".handle\");\n    const isHandle = Array.prototype.includes.call(handles, el);\n    const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));\n    return isHandle || isChild;\n  }\n\n  /**\n   * take in the value from the \"range\" parameter and see if\n   * we should make a min/max/range slider.\n   * @param {array} values the input values for the rangeSlider\n   * @return {array} the range array for creating a rangeSlider\n   **/\n  function trimRange(values) {\n    if (range === \"min\" || range === \"max\") {\n      return values.slice(0, 1);\n    } else if (range) {\n      return values.slice(0, 2);\n    } else {\n      return values;\n    }\n  }\n\n  /**\n   * helper to return the slider dimensions for finding\n   * the closest handle to user interaction\n   * @return {object} the range slider DOM client rect\n   **/\n  function getSliderDimensions() {\n    return slider.getBoundingClientRect();\n  }\n\n  /**\n   * helper to return closest handle to user interaction\n   * @param {number} clientPos the pixel (clientX/Y) to check against\n   * @return {number} the index of the closest handle to clientPos\n   **/\n  function getClosestHandle(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let iPos = 0;\n    let iPercent = 0;\n    let iVal = 0;\n    if (vertical) {\n      iPos = clientPos - dims.top;\n      iPercent = (iPos / dims.height) * 100;\n      iVal = ((max - min) / 100) * iPercent + min;\n    } else {\n      iPos = clientPos - dims.left;\n      iPercent = (iPos / dims.width) * 100;\n      iVal = ((max - min) / 100) * iPercent + min;\n    }\n\n    let closest;\n\n    // if we have a range, and the handles are at the same\n    // position, we want a simple check if the interaction\n    // value is greater than return the second handle\n    if (range === true && values[0] === values[1]) {\n      if (iVal > values[1]) {\n        return 1;\n      } else {\n        return 0;\n      }\n      // if there are multiple handles, and not a range, then\n      // we sort the handles values, and return the first one closest\n      // to the interaction value\n    } else {\n      closest = values.indexOf(\n        [...values].sort((a, b) => Math.abs(iVal - a) - Math.abs(iVal - b))[0]\n      );\n    }\n    return closest;\n  }\n\n  /**\n   * take the interaction position on the slider, convert\n   * it to a value on the range, and then send that value\n   * through to the moveHandle() method to set the active\n   * handle's position\n   * @param {number} clientPos the clientX/Y of the interaction\n   **/\n  function handleInteract(clientPos) {\n    // first make sure we have the latest dimensions\n    // of the slider, as it may have changed size\n    const dims = getSliderDimensions();\n    // calculate the interaction position, percent and value\n    let iPos = 0;\n    let iPercent = 0;\n    let iVal = 0;\n    if (vertical) {\n      iPos = clientPos - dims.top;\n      iPercent = (iPos / dims.height) * 100;\n      iVal = ((max - min) / 100) * iPercent + min;\n    } else {\n      iPos = clientPos - dims.left;\n      iPercent = (iPos / dims.width) * 100;\n      iVal = ((max - min) / 100) * iPercent + min;\n    }\n    // move handle to the value\n    moveHandle(activeHandle, iVal);\n  }\n\n  /**\n   * move a handle to a specific value, respecting the clamp/align rules\n   * @param {number} index the index of the handle we want to move\n   * @param {number} value the value to move the handle to\n   * @return {number} the value that was moved to (after alignment/clamping)\n   **/\n  function moveHandle(index, value) {\n    // restrict the handles of a range-slider from\n    // going past one-another\n    if (range && index === 0 && value > values[1]) {\n      value = values[1];\n    } else if (range && index === 1 && value < values[0]) {\n      value = values[0];\n    }\n    // set the value for the handle, and align/clamp it\n    values[index] = value;\n  }\n\n  /**\n   * helper to find the beginning range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the beginning of the range\n   **/\n  function rangeStart(values) {\n    if (range === \"min\") {\n      return 0;\n    } else {\n      return values[0];\n    }\n  }\n\n  /**\n   * helper to find the ending range value for use with css style\n   * @param {array} values the input values for the rangeSlider\n   * @return {number} the end of the range\n   **/\n  function rangeEnd(values) {\n    if (range === \"max\") {\n      return 0;\n    } else if (range === \"min\") {\n      return 100 - values[0];\n    } else {\n      return 100 - values[1];\n    }\n  }\n\n  /**\n   * when the user has unfocussed (blurred) from the\n   * slider, deactivated all handles\n   * @param {event} e the event from browser\n   **/\n  function sliderBlurHandle(e) {\n    if (keyboardActive) {\n      focus = false;\n      handleActivated = false;\n    }\n  }\n\n  /**\n   * when the user focusses the handle of a slider\n   * set it to be active\n   * @param {event} e the event from browser\n   **/\n  function sliderFocusHandle(e) {\n    activeHandle = index(e.target);\n    focus = true;\n  }\n\n  /**\n   * handle the keyboard accessible features by checking the\n   * input type, and modfier key then moving handle by appropriate amount\n   * @param {event} e the event from browser\n   **/\n  function sliderKeydown(e) {\n    const handle = index(e.target);\n    let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;\n    let prevent = false;\n\n    switch (e.key) {\n      case \"PageDown\":\n        jump *= 10;\n      case \"ArrowRight\":\n      case \"ArrowUp\":\n        moveHandle(handle, values[handle] + jump);\n        prevent = true;\n        break;\n      case \"PageUp\":\n        jump *= 10;\n      case \"ArrowLeft\":\n      case \"ArrowDown\":\n        moveHandle(handle, values[handle] - jump);\n        prevent = true;\n        break;\n      case \"Home\":\n        moveHandle(handle, min);\n        prevent = true;\n        break;\n      case \"End\":\n        moveHandle(handle, max);\n        prevent = true;\n        break;\n    }\n    if (prevent) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  /**\n   * function to run when the user touches\n   * down on the slider element anywhere\n   * @param {event} e the event from browser\n   **/\n  function sliderInteractStart(e) {\n    const p = eventPosition(e);\n    // set the closest handle as active\n    focus = true;\n    handleActivated = true;\n    activeHandle = getClosestHandle(p);\n    // for touch devices we want the handle to instantly\n    // move to the position touched for more responsive feeling\n    if (e.type === \"touchstart\") {\n      handleInteract(p);\n    }\n  }\n\n  /**\n   * unfocus the slider if the user clicked off of\n   * it, somewhere else on the screen\n   * @param {event} e the event from browser\n   **/\n  function bodyInteractStart(e) {\n    keyboardActive = false;\n    if (focus && e.target !== slider && !slider.contains(e.target)) {\n      focus = false;\n    }\n  }\n\n  /**\n   * send the clientX through to handle the interaction\n   * whenever the user moves acros screen while active\n   * @param {event} e the event from browser\n   **/\n  function bodyInteract(e) {\n    if (handleActivated) {\n      handleInteract(eventPosition(e));\n    }\n  }\n\n  /**\n   * if user triggers mouseup on the body while\n   * a handle is active (without moving) then we\n   * trigger an interact event there\n   * @param {event} e the event from browser\n   **/\n  function bodyMouseUp(e) {\n    const el = e.target;\n    // this only works if a handle is active, which can\n    // only happen if there was sliderInteractStart triggered\n    // on the slider, already\n    if (handleActivated && (el === slider || slider.contains(el))) {\n      focus = true;\n      if (!targetIsHandle(el)) {\n        handleInteract(eventPosition(e));\n      }\n    }\n    handleActivated = false;\n  }\n\n  /**\n   * if user triggers touchend on the body then we\n   * defocus the slider completely\n   * @param {event} e the event from browser\n   **/\n  function bodyTouchEnd(e) {\n    handleActivated = false;\n  }\n\n  function bodyKeyDown(e) {\n    if (e.target === slider || slider.contains(e.target)) {\n      keyboardActive = true;\n    }\n  }\n</script>\n\n<style>\n  :global(.rangeSlider) {\n    --slider: var(--range-slider, #d7dada);\n    --handle-inactive: var(--range-handle-inactive, #99a2a2);\n    --handle: var(--range-handle, #838de7);\n    --handle-focus: var(--range-handle-focus, #4a40d4);\n    --range-inactive: var(--range-range-inactive, var(--handle-inactive));\n    --range: var(--range-range, var(--handle-focus));\n    --float-inactive: var(--range-float-inactive, var(--handle-inactive));\n    --float: var(--range-float, var(--handle-focus));\n    --float-text: var(--range-float-text, white);\n  }\n  :global(.rangeSlider) {\n    position: relative;\n    border-radius: 100px;\n    height: 0.5em;\n    margin: 1em;\n  }\n  :global(.rangeSlider, .rangeSlider *) {\n    user-select: none;\n  }\n  :global(.rangeSlider.pips) {\n    margin-bottom: 1.8em;\n  }\n  :global(.rangeSlider.pip-labels) {\n    margin-bottom: 2.8em;\n  }\n  :global(.rangeSlider.vertical) {\n    display: inline-block;\n    border-radius: 100px;\n    width: 0.5em;\n    min-height: 200px;\n  }\n  :global(.rangeSlider.vertical.pips) {\n    margin-right: 1.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider.vertical.pip-labels) {\n    margin-right: 2.8em;\n    margin-bottom: 1em;\n  }\n  :global(.rangeSlider .rangeHandle) {\n    position: absolute;\n    display: block;\n    height: 1.4em;\n    width: 1.4em;\n    top: 0.25em;\n    left: 0.25em;\n    transform: translateY(-50%) translateX(-50%);\n    z-index: 2;\n  }\n  :global(.rangeSlider .rangeNub) {\n    position: absolute;\n    left: 0;\n    top: 0;\n    display: block;\n    border-radius: 10em;\n    height: 100%;\n    width: 100%;\n    transition: all 0.2s ease;\n  }\n  :global(.rangeSlider.range:not(.min):not(.max) .rangeNub) {\n    border-radius: 10em 10em 10em 1.6em;\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-135deg);\n  }\n  :global(.rangeSlider.range .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(45deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(1) .rangeNub) {\n    transform: rotate(-45deg);\n  }\n  :global(.rangeSlider.range.vertical .rangeHandle:nth-of-type(2) .rangeNub) {\n    transform: rotate(135deg);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    display: block;\n    position: absolute;\n    left: 50%;\n    top: -0.5em;\n    transform: translate(-50%, -100%);\n    font-size: 1em;\n    text-align: center;\n    opacity: 0;\n    pointer-events: none;\n    white-space: nowrap;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n    padding: 0.2em 0.4em;\n    border-radius: 0.2em;\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeFloat),\n  :global(.rangeSlider .rangeHandle.hoverable:hover .rangeFloat) {\n    opacity: 1;\n    top: -0.2em;\n    transform: translate(-50%, -100%);\n  }\n  :global(.rangeSlider .rangeBar) {\n    position: absolute;\n    display: block;\n    transition: background 0.2s ease;\n    border-radius: 1em;\n    height: 0.5em;\n    top: 0;\n    user-select: none;\n    z-index: 1;\n  }\n  :global(.rangeSlider.vertical .rangeBar) {\n    width: 0.5em;\n    height: auto;\n  }\n  :global(.rangeSlider) {\n    background-color: #d7dada;\n    background-color: var(--slider);\n  }\n  :global(.rangeSlider .rangeBar) {\n    background-color: #99a2a2;\n    background-color: var(--range-inactive);\n  }\n  :global(.rangeSlider.focus .rangeBar) {\n    background-color: #838de7;\n    background-color: var(--range);\n  }\n  :global(.rangeSlider .rangeNub) {\n    background-color: #99a2a2;\n    background-color: var(--handle-inactive);\n  }\n  :global(.rangeSlider.focus .rangeNub) {\n    background-color: #838de7;\n    background-color: var(--handle);\n  }\n  :global(.rangeSlider .rangeHandle.active .rangeNub) {\n    background-color: #4a40d4;\n    background-color: var(--handle-focus);\n  }\n  :global(.rangeSlider .rangeFloat) {\n    color: white;\n    color: var(--float-text);\n    background-color: #99a2a2;\n    background-color: var(--float-inactive);\n  }\n  :global(.rangeSlider.focus .rangeFloat) {\n    background-color: #4a40d4;\n    background-color: var(--float);\n  }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zdmVsdGUtcmFuZ2Utc2xpZGVyLXBpcHMvc3JjL1JhbmdlU2xpZGVyLnN2ZWx0ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0VBQ0U7SUFDRSxzQ0FBc0M7SUFDdEMsd0RBQXdEO0lBQ3hELHNDQUFzQztJQUN0QyxrREFBa0Q7SUFDbEQscUVBQXFFO0lBQ3JFLGdEQUFnRDtJQUNoRCxxRUFBcUU7SUFDckUsZ0RBQWdEO0lBQ2hELDRDQUE0QztFQUM5QztFQUNBO0lBQ0Usa0JBQWtCO0lBQ2xCLG9CQUFvQjtJQUNwQixhQUFhO0lBQ2IsV0FBVztFQUNiO0VBQ0E7SUFDRSxpQkFBaUI7RUFDbkI7RUFDQTtJQUNFLG9CQUFvQjtFQUN0QjtFQUNBO0lBQ0Usb0JBQW9CO0VBQ3RCO0VBQ0E7SUFDRSxxQkFBcUI7SUFDckIsb0JBQW9CO0lBQ3BCLFlBQVk7SUFDWixpQkFBaUI7RUFDbkI7RUFDQTtJQUNFLG1CQUFtQjtJQUNuQixrQkFBa0I7RUFDcEI7RUFDQTtJQUNFLG1CQUFtQjtJQUNuQixrQkFBa0I7RUFDcEI7RUFDQTtJQUNFLGtCQUFrQjtJQUNsQixjQUFjO0lBQ2QsYUFBYTtJQUNiLFlBQVk7SUFDWixXQUFXO0lBQ1gsWUFBWTtJQUNaLDRDQUE0QztJQUM1QyxVQUFVO0VBQ1o7RUFDQTtJQUNFLGtCQUFrQjtJQUNsQixPQUFPO0lBQ1AsTUFBTTtJQUNOLGNBQWM7SUFDZCxtQkFBbUI7SUFDbkIsWUFBWTtJQUNaLFdBQVc7SUFDWCx5QkFBeUI7RUFDM0I7RUFDQTtJQUNFLG1DQUFtQztFQUNyQztFQUNBO0lBQ0UsMEJBQTBCO0VBQzVCO0VBQ0E7SUFDRSx3QkFBd0I7RUFDMUI7RUFDQTtJQUNFLHlCQUF5QjtFQUMzQjtFQUNBO0lBQ0UseUJBQXlCO0VBQzNCO0VBQ0E7SUFDRSxjQUFjO0lBQ2Qsa0JBQWtCO0lBQ2xCLFNBQVM7SUFDVCxXQUFXO0lBQ1gsaUNBQWlDO0lBQ2pDLGNBQWM7SUFDZCxrQkFBa0I7SUFDbEIsVUFBVTtJQUNWLG9CQUFvQjtJQUNwQixtQkFBbUI7SUFDbkIseUJBQXlCO0lBQ3pCLGdCQUFnQjtJQUNoQixvQkFBb0I7SUFDcEIsb0JBQW9CO0VBQ3RCO0VBQ0E7O0lBRUUsVUFBVTtJQUNWLFdBQVc7SUFDWCxpQ0FBaUM7RUFDbkM7RUFDQTtJQUNFLGtCQUFrQjtJQUNsQixjQUFjO0lBQ2QsZ0NBQWdDO0lBQ2hDLGtCQUFrQjtJQUNsQixhQUFhO0lBQ2IsTUFBTTtJQUNOLGlCQUFpQjtJQUNqQixVQUFVO0VBQ1o7RUFDQTtJQUNFLFlBQVk7SUFDWixZQUFZO0VBQ2Q7RUFDQTtJQUNFLHlCQUF5QjtJQUN6QiwrQkFBK0I7RUFDakM7RUFDQTtJQUNFLHlCQUF5QjtJQUN6Qix1Q0FBdUM7RUFDekM7RUFDQTtJQUNFLHlCQUF5QjtJQUN6Qiw4QkFBOEI7RUFDaEM7RUFDQTtJQUNFLHlCQUF5QjtJQUN6Qix3Q0FBd0M7RUFDMUM7RUFDQTtJQUNFLHlCQUF5QjtJQUN6QiwrQkFBK0I7RUFDakM7RUFDQTtJQUNFLHlCQUF5QjtJQUN6QixxQ0FBcUM7RUFDdkM7RUFDQTtJQUNFLFlBQVk7SUFDWix3QkFBd0I7SUFDeEIseUJBQXlCO0lBQ3pCLHVDQUF1QztFQUN6QztFQUNBO0lBQ0UseUJBQXlCO0lBQ3pCLDhCQUE4QjtFQUNoQyIsImZpbGUiOiJub2RlX21vZHVsZXMvc3ZlbHRlLXJhbmdlLXNsaWRlci1waXBzL3NyYy9SYW5nZVNsaWRlci5zdmVsdGUiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgOmdsb2JhbCgucmFuZ2VTbGlkZXIpIHtcbiAgICAtLXNsaWRlcjogdmFyKC0tcmFuZ2Utc2xpZGVyLCAjZDdkYWRhKTtcbiAgICAtLWhhbmRsZS1pbmFjdGl2ZTogdmFyKC0tcmFuZ2UtaGFuZGxlLWluYWN0aXZlLCAjOTlhMmEyKTtcbiAgICAtLWhhbmRsZTogdmFyKC0tcmFuZ2UtaGFuZGxlLCAjODM4ZGU3KTtcbiAgICAtLWhhbmRsZS1mb2N1czogdmFyKC0tcmFuZ2UtaGFuZGxlLWZvY3VzLCAjNGE0MGQ0KTtcbiAgICAtLXJhbmdlLWluYWN0aXZlOiB2YXIoLS1yYW5nZS1yYW5nZS1pbmFjdGl2ZSwgdmFyKC0taGFuZGxlLWluYWN0aXZlKSk7XG4gICAgLS1yYW5nZTogdmFyKC0tcmFuZ2UtcmFuZ2UsIHZhcigtLWhhbmRsZS1mb2N1cykpO1xuICAgIC0tZmxvYXQtaW5hY3RpdmU6IHZhcigtLXJhbmdlLWZsb2F0LWluYWN0aXZlLCB2YXIoLS1oYW5kbGUtaW5hY3RpdmUpKTtcbiAgICAtLWZsb2F0OiB2YXIoLS1yYW5nZS1mbG9hdCwgdmFyKC0taGFuZGxlLWZvY3VzKSk7XG4gICAgLS1mbG9hdC10ZXh0OiB2YXIoLS1yYW5nZS1mbG9hdC10ZXh0LCB3aGl0ZSk7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VTbGlkZXIpIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG4gICAgaGVpZ2h0OiAwLjVlbTtcbiAgICBtYXJnaW46IDFlbTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlciwgLnJhbmdlU2xpZGVyICopIHtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlci5waXBzKSB7XG4gICAgbWFyZ2luLWJvdHRvbTogMS44ZW07XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VTbGlkZXIucGlwLWxhYmVscykge1xuICAgIG1hcmdpbi1ib3R0b206IDIuOGVtO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyLnZlcnRpY2FsKSB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xuICAgIHdpZHRoOiAwLjVlbTtcbiAgICBtaW4taGVpZ2h0OiAyMDBweDtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlci52ZXJ0aWNhbC5waXBzKSB7XG4gICAgbWFyZ2luLXJpZ2h0OiAxLjhlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAxZW07XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VTbGlkZXIudmVydGljYWwucGlwLWxhYmVscykge1xuICAgIG1hcmdpbi1yaWdodDogMi44ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogMWVtO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyIC5yYW5nZUhhbmRsZSkge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBoZWlnaHQ6IDEuNGVtO1xuICAgIHdpZHRoOiAxLjRlbTtcbiAgICB0b3A6IDAuMjVlbTtcbiAgICBsZWZ0OiAwLjI1ZW07XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgei1pbmRleDogMjtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlciAucmFuZ2VOdWIpIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgYm9yZGVyLXJhZGl1czogMTBlbTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlci5yYW5nZTpub3QoLm1pbik6bm90KC5tYXgpIC5yYW5nZU51Yikge1xuICAgIGJvcmRlci1yYWRpdXM6IDEwZW0gMTBlbSAxMGVtIDEuNmVtO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyLnJhbmdlIC5yYW5nZUhhbmRsZTpudGgtb2YtdHlwZSgxKSAucmFuZ2VOdWIpIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtMTM1ZGVnKTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlci5yYW5nZSAucmFuZ2VIYW5kbGU6bnRoLW9mLXR5cGUoMikgLnJhbmdlTnViKSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyLnJhbmdlLnZlcnRpY2FsIC5yYW5nZUhhbmRsZTpudGgtb2YtdHlwZSgxKSAucmFuZ2VOdWIpIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyLnJhbmdlLnZlcnRpY2FsIC5yYW5nZUhhbmRsZTpudGgtb2YtdHlwZSgyKSAucmFuZ2VOdWIpIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxMzVkZWcpO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyIC5yYW5nZUZsb2F0KSB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0b3A6IC0wLjVlbTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtMTAwJSk7XG4gICAgZm9udC1zaXplOiAxZW07XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlO1xuICAgIGZvbnQtc2l6ZTogMC45ZW07XG4gICAgcGFkZGluZzogMC4yZW0gMC40ZW07XG4gICAgYm9yZGVyLXJhZGl1czogMC4yZW07XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VTbGlkZXIgLnJhbmdlSGFuZGxlLmFjdGl2ZSAucmFuZ2VGbG9hdCksXG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyIC5yYW5nZUhhbmRsZS5ob3ZlcmFibGU6aG92ZXIgLnJhbmdlRmxvYXQpIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRvcDogLTAuMmVtO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC0xMDAlKTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlciAucmFuZ2VCYXIpIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjJzIGVhc2U7XG4gICAgYm9yZGVyLXJhZGl1czogMWVtO1xuICAgIGhlaWdodDogMC41ZW07XG4gICAgdG9wOiAwO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIHotaW5kZXg6IDE7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VTbGlkZXIudmVydGljYWwgLnJhbmdlQmFyKSB7XG4gICAgd2lkdGg6IDAuNWVtO1xuICAgIGhlaWdodDogYXV0bztcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlcikge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNkN2RhZGE7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2xpZGVyKTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlciAucmFuZ2VCYXIpIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTlhMmEyO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXJhbmdlLWluYWN0aXZlKTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlci5mb2N1cyAucmFuZ2VCYXIpIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODM4ZGU3O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXJhbmdlKTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlciAucmFuZ2VOdWIpIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTlhMmEyO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWhhbmRsZS1pbmFjdGl2ZSk7XG4gIH1cbiAgOmdsb2JhbCgucmFuZ2VTbGlkZXIuZm9jdXMgLnJhbmdlTnViKSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzgzOGRlNztcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1oYW5kbGUpO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyIC5yYW5nZUhhbmRsZS5hY3RpdmUgLnJhbmdlTnViKSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRhNDBkNDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1oYW5kbGUtZm9jdXMpO1xuICB9XG4gIDpnbG9iYWwoLnJhbmdlU2xpZGVyIC5yYW5nZUZsb2F0KSB7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIGNvbG9yOiB2YXIoLS1mbG9hdC10ZXh0KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOTlhMmEyO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWZsb2F0LWluYWN0aXZlKTtcbiAgfVxuICA6Z2xvYmFsKC5yYW5nZVNsaWRlci5mb2N1cyAucmFuZ2VGbG9hdCkge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM0YTQwZDQ7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZmxvYXQpO1xuICB9XG4iXX0= */</style>\n\n<div\n  {id}\n  bind:this={slider}\n  class=\"rangeSlider\"\n  class:range\n  class:vertical\n  class:focus\n  class:min={range === 'min'}\n  class:max={range === 'max'}\n  class:pips\n  class:pip-labels={all === 'label' || first === 'label' || last === 'label' || rest === 'label'}\n  on:touchstart|preventDefault={sliderInteractStart}\n  on:mousedown={sliderInteractStart}>\n  {#each values as value, index}\n    <span\n      role=\"slider\"\n      tabindex=\"0\"\n      class=\"rangeHandle\"\n      class:hoverable={hover}\n      class:active={focus && activeHandle === index}\n      on:blur={sliderBlurHandle}\n      on:focus={sliderFocusHandle}\n      on:keydown={sliderKeydown}\n      style=\"{vertical ? 'top' : 'left'}: {$springPositions[index]}%; z-index: {activeHandle === index ? 3 : 2};\"\n      aria-valuemin={range === true && index === 1 ? values[0] : min}\n      aria-valuemax={range === true && index === 0 ? values[1] : max}\n      aria-valuenow={value}\n      aria-valuetext=\"{prefix}{handleFormatter(value)}{suffix}\"\n      aria-orientation={vertical ? 'vertical' : 'horizontal'}>\n      <span class=\"rangeNub\" />\n      {#if float}\n        <span class=\"rangeFloat\">{prefix}{handleFormatter(value)}{suffix}</span>\n      {/if}\n    </span>\n  {/each}\n  {#if range}\n    <span\n      class=\"rangeBar\"\n      style=\"{vertical ? 'top' : 'left'}: {rangeStart($springPositions)}%; {vertical ? 'bottom' : 'right'}:\n      {rangeEnd($springPositions)}%;\" />\n  {/if}\n  {#if pips}\n    <RangePips\n      {values}\n      {min}\n      {max}\n      {step}\n      {range}\n      {vertical}\n      {all}\n      {first}\n      {last}\n      {rest}\n      {pipstep}\n      {prefix}\n      {suffix}\n      {formatter}\n      {focus}\n      {percentOf} />\n  {/if}\n</div>\n\n<svelte:window\n  on:mousedown={bodyInteractStart}\n  on:touchstart={bodyInteractStart}\n  on:mousemove={bodyInteract}\n  on:touchmove={bodyInteract}\n  on:mouseup={bodyMouseUp}\n  on:touchend={bodyTouchEnd}\n  on:keydown={bodyKeyDown} />\n",
    "<script>\n  import Isomer, { Point, Path, Shape, Vector, Color } from 'isomer'\n  import { onMount } from 'svelte'\n  import { watchResize } from 'svelte-watch-resize'\n\n  let canvas\n  let canvasW\n  let canvasH\n  export let w\n  export let l\n  export let h\n\n  // onMount(() => setTimeout(() => draw(canvasW, canvasH)))\n\n  $: if (canvas && l && w && h) {\n    draw(canvas.clientWidth, canvas.clientHeight)\n  }\n\n  function draw(cW, cH) {\n    canvasW = cW\n    canvasH = cH\n    console.log(cW, cH)\n    if (!canvas) return\n    canvas.width = cW * 2\n    canvas.height = cH * 2\n    const scale = (Math.min(cW, cH) * 2) / (w + l)\n    console.log(scale)\n    var iso = new Isomer(canvas, { scale })\n    iso.canvas.clear()\n    var red = new Color(160, 60, 50)\n    var trans = new Color(200, 200, 200, 0.1)\n    var win = new Color(100, 150, 250, 0.2)\n    var wall = new Color(230, 230, 230)\n    var door = new Color(210, 210, 210)\n    var wallSize = 20\n\n    var length = l + 2 * wallSize\n    var width = w + 2 * wallSize\n\n    iso.add(\n      Shape.Prism(Point(length - wallSize, 0, 0), wallSize, width, h),\n      wall\n    )\n    iso.add(\n      Shape.Prism(Point(0, width - wallSize, 0), length - wallSize, 20, h),\n      wall\n    )\n\n    ww(100, width - wallSize)\n    ww(250, width - wallSize)\n    ww(400, width - wallSize)\n    ww(550, width - wallSize)\n    ww(700, width - wallSize)\n\n    iso.add(Shape.Prism(Point(0, 0, 0), length, wallSize, h), trans)\n    iso.add(Shape.Prism(Point(0, 0, 0), wallSize, width, h), trans)\n\n    iso.add(\n      new Path([\n        Point(length - 200, 0, 0),\n        Point(length - 110, 0, 0),\n        Point(length - 110, 0, 200),\n        Point(length - 200, 0, 200),\n      ]),\n      door\n    )\n\n    ww(100, 0)\n    ww(250, 0)\n    ww(400, 0)\n    ww(550, 0)\n\n    function ww(x, y) {\n      iso.add(\n        new Path([\n          Point(x, y, 100),\n          Point(x + 50, y, 100),\n          Point(x + 50, y, 150),\n          Point(x, y, 150),\n        ]),\n        win\n      )\n\n      iso.add(\n        new Path([\n          Point(x + 60, y, 100),\n          Point(x + 110, y, 100),\n          Point(x + 110, y, 150),\n          Point(x + 60, y, 150),\n        ]),\n        win\n      )\n\n      iso.add(\n        new Path([\n          Point(x, y, 160),\n          Point(x + 50, y, 160),\n          Point(x + 50, y, 210),\n          Point(x, y, 210),\n        ]),\n        win\n      )\n\n      iso.add(\n        new Path([\n          Point(x + 60, y, 160),\n          Point(x + 110, y, 160),\n          Point(x + 110, y, 210),\n          Point(x + 60, y, 210),\n        ]),\n        win\n      )\n    }\n  }\n</script>\n\n<div use:watchResize={n => draw(n.clientWidth, n.clientHeight)}>\n  <canvas bind:this={canvas} style=\"width: 100%; height: 100%\" />\n</div>\n\n<style>\n  div {\n    width: 100%;\n    height: 100%;\n  }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Sb29tLnN2ZWx0ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0VBQ0U7SUFDRSxXQUFXO0lBQ1gsWUFBWTtFQUNkIiwiZmlsZSI6InNyYy9Sb29tLnN2ZWx0ZSIsInNvdXJjZXNDb250ZW50IjpbIlxuICBkaXYge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgfVxuIl19 */</style>\n"
  ],
  "names": [],
  "mappings": "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"
}